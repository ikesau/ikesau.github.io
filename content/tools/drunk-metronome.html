---
title: "Drunk Metronome"
description: "An intentionally unstable metronome that wobbles around a target tempo."
---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Drunk Metronome</title>
    <meta
      name="description"
      content="Play along with a metronome that drifts around a target tempo to create a loose, tipsy feel."
    />
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
      }

      body {
        margin: 0;
        padding: 0;
        background: var(--page-background, #fafafa);
        color: var(--page-foreground, #212121);
      }

      .container {
        max-width: 720px;
        margin: 0 auto;
        padding: 24px 16px 48px;
      }

      h1 {
        margin-bottom: 0.2em;
        font-size: clamp(2rem, 4vw, 2.8rem);
      }

      p.description {
        margin-top: 0;
        margin-bottom: 1.5em;
        line-height: 1.5;
        color: #555;
      }

      .controls {
        display: grid;
        gap: 18px;
        margin-bottom: 24px;
      }

      .control {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      label {
        font-weight: 600;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      input[type="number"],
      input[type="range"] {
        width: 100%;
      }

      input[type="number"] {
        padding: 10px 12px;
        border-radius: 6px;
        border: 1px solid rgba(0, 0, 0, 0.18);
        font-size: 1rem;
      }

      input[type="range"] {
        cursor: pointer;
      }

      .value-badge {
        font-size: 0.85rem;
        background: rgba(0, 0, 0, 0.08);
        color: inherit;
        padding: 4px 10px;
        min-width: 44px;
        text-align: center;
      }

      .buttons {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      button {
        appearance: none;
        border: none;
        padding: 10px 20px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        background: #222;
        color: #fff;
        transition: transform 120ms ease, filter 120ms ease,
          background-color 120ms ease;
      }

      button:hover {
        transform: translateY(-1px);
        filter: brightness(1.05);
      }

      button:active {
        transform: translateY(0);
        filter: brightness(0.92);
      }

      button.secondary {
        background: rgba(0, 0, 0, 0.08);
        color: inherit;
      }

      .status {
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
        margin-top: 28px;
        padding: 16px 20px;
        background: rgba(0, 0, 0, 0.05);
      }

      .status-item {
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 140px;
      }

      .status-label {
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: rgba(0, 0, 0, 0.55);
      }

      .status-value {
        font-size: 1.3rem;
        font-weight: 700;
      }

      @media (prefers-color-scheme: dark) {
        body {
          --page-background: #111;
          --page-foreground: #f5f5f5;
        }

        input[type="number"] {
          background: rgba(255, 255, 255, 0.02);
          border-color: rgba(255, 255, 255, 0.15);
          color: inherit;
        }

        .value-badge {
          background: rgba(255, 255, 255, 0.12);
        }

        button.secondary {
          background: rgba(255, 255, 255, 0.08);
        }

        .status {
          background: rgba(255, 255, 255, 0.08);
        }

        .status-label {
          color: rgba(255, 255, 255, 0.6);
        }

        .tips {
          color: rgba(255, 255, 255, 0.7);
        }
      }
    </style>
  </head>
  <body>
    <main class="container">
      <h1>Drunk Metronome</h1>

      <section class="controls">
        <div class="control">
          <label for="beatsPerBarInput">
            Beats per bar
            <span class="value-badge" id="beatsPerBarDisplay">4</span>
          </label>
          <input
            type="range"
            id="beatsPerBarInput"
            value="4"
            min="1"
            max="16"
          />
        </div>

        <div class="control">
          <label for="tempoSlider">
            Target tempo (BPM)
            <span class="value-badge" id="tempoDisplay">100</span>
          </label>
          <input
            type="range"
            id="tempoSlider"
            min="40"
            max="240"
            step="1"
            value="100"
          />
        </div>

        <div class="control">
          <label for="varianceSlider">
            Variance range (± BPM)
            <span class="value-badge" id="varianceDisplay">10</span>
          </label>
          <input
            type="range"
            id="varianceSlider"
            min="0"
            max="60"
            step="1"
            value="10"
          />
        </div>

        <div class="control">
          <label for="erraticSlider">
            Erraticness
            <span class="value-badge" id="erraticDisplay">Steady-ish</span>
          </label>
          <input
            type="range"
            id="erraticSlider"
            min="1"
            max="3"
            step="1"
            value="2"
          />
        </div>
      </section>

      <div class="buttons">
        <button id="startStopBtn">Start</button>
        <button class="secondary" id="resetBtn">Reset feel</button>
      </div>

      <div class="control" style="margin-top: 24px">
        <label for="exportDuration">
          Export duration (mm:ss)
          <input
            type="text"
            id="exportDuration"
            value="2:00"
            style="width: 80px; padding: 6px 8px; font-size: 0.95rem"
            pattern="\d{1,2}:\d{2}"
          />
        </label>
      </div>

      <div class="buttons">
        <button id="exportBtn" class="secondary">Export WAV</button>
        <span
          id="exportStatus"
          style="margin-left: 12px; line-height: 40px; color: #666"
        ></span>
      </div>

      <section class="status">
        <div class="status-item">
          <span class="status-label">Current bpm</span>
          <span class="status-value" id="currentBpmReadout">—</span>
        </div>
        <div class="status-item">
          <span class="status-label">Beat in bar</span>
          <span class="status-value" id="beatPositionReadout">—</span>
        </div>
        <div class="status-item">
          <span class="status-label">Target wobble</span>
          <span class="status-value" id="targetBpmReadout">—</span>
        </div>
      </section>
    </main>

    <script>
      const beatsPerBarInput = document.getElementById("beatsPerBarInput");
      const tempoSlider = document.getElementById("tempoSlider");
      const varianceSlider = document.getElementById("varianceSlider");
      const erraticSlider = document.getElementById("erraticSlider");
      const startStopBtn = document.getElementById("startStopBtn");
      const resetBtn = document.getElementById("resetBtn");

      const beatsPerBarDisplay = document.getElementById("beatsPerBarDisplay");
      const tempoDisplay = document.getElementById("tempoDisplay");
      const varianceDisplay = document.getElementById("varianceDisplay");
      const erraticDisplay = document.getElementById("erraticDisplay");

      const currentBpmReadout = document.getElementById("currentBpmReadout");
      const beatPositionReadout = document.getElementById(
        "beatPositionReadout"
      );
      const targetBpmReadout = document.getElementById("targetBpmReadout");

      const erraticLabels = {
        1: "Chill",
        2: "Steady-ish",
        3: "Unhinged",
      };

      let audioContext;
      let isRunning = false;
      let beatIndex = 0;
      let currentBpm = Number(tempoSlider.value);
      let targetBpm = currentBpm;

      // Timing variables for precise scheduling
      let nextBeatTime = 0; // When the next beat should play (in audio context time)
      let schedulerTimer = null;
      const SCHEDULER_INTERVAL = 25; // How often to run the scheduler (ms)
      const LOOKAHEAD_TIME = 0.1; // How far ahead to schedule beats (seconds)

      const erraticProfiles = {
        1: { changeChance: 0.14, rangeScale: 0.35, smoothing: 0.2 },
        2: { changeChance: 0.32, rangeScale: 0.7, smoothing: 0.32 },
        3: { changeChance: 0.6, rangeScale: 1, smoothing: 0.52 },
      };

      beatsPerBarInput.addEventListener("input", () => {
        beatsPerBarDisplay.textContent = beatsPerBarInput.value;
        enforceBeatBounds();
      });

      tempoSlider.addEventListener("input", () => {
        tempoDisplay.textContent = tempoSlider.value;
        if (!isRunning) {
          currentBpm = Number(tempoSlider.value);
          targetBpm = currentBpm;
          currentBpmReadout.textContent = tempoSlider.value;
          targetBpmReadout.textContent = tempoSlider.value;
        }
      });

      varianceSlider.addEventListener("input", () => {
        varianceDisplay.textContent = varianceSlider.value;
      });

      erraticSlider.addEventListener("input", () => {
        erraticDisplay.textContent = erraticLabels[erraticSlider.value];
      });

      startStopBtn.addEventListener("click", () => {
        if (isRunning) {
          stopMetronome();
        } else {
          startMetronome();
        }
      });

      resetBtn.addEventListener("click", () => {
        targetBpm = Number(tempoSlider.value);
        currentBpm = targetBpm;
        if (isRunning) {
          beatIndex = 0;
        }
        updateStatusDisplays();
      });

      function enforceBeatBounds() {
        const parsed = Math.max(
          1,
          Math.min(16, Number(beatsPerBarInput.value) || 4)
        );
        beatsPerBarInput.value = parsed;
        beatsPerBarDisplay.textContent = parsed;
      }

      function startMetronome() {
        enforceBeatBounds();
        if (!audioContext) {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
        }
        audioContext.resume();

        isRunning = true;
        beatIndex = 0;
        currentBpm = Number(tempoSlider.value);
        targetBpm = currentBpm;

        // Start the first beat immediately
        nextBeatTime = audioContext.currentTime;

        // Start the scheduler loop
        scheduler();
        schedulerTimer = setInterval(scheduler, SCHEDULER_INTERVAL);

        startStopBtn.textContent = "Stop";
        updateStatusDisplays();
      }

      function stopMetronome() {
        isRunning = false;
        if (schedulerTimer) {
          clearInterval(schedulerTimer);
          schedulerTimer = null;
        }
        beatIndex = 0;
        startStopBtn.textContent = "Start";
        currentBpmReadout.textContent = "—";
        beatPositionReadout.textContent = "—";
        targetBpmReadout.textContent = "—";
      }

      function scheduler() {
        if (!isRunning || !audioContext) return;

        // Schedule all beats that fall within our lookahead window
        while (nextBeatTime < audioContext.currentTime + LOOKAHEAD_TIME) {
          scheduleNote(nextBeatTime);
          advanceToNextBeat();
        }
      }

      function scheduleNote(time) {
        const beatsPerBar = Number(beatsPerBarInput.value);
        const isDownbeat = beatIndex % beatsPerBar === 0;

        // Play the click at the precise time
        playClick(isDownbeat, time);

        // Update display when this beat actually plays
        // We use a timeout synchronized to when the beat will actually sound
        const displayDelay = Math.max(
          0,
          (time - audioContext.currentTime) * 1000
        );
        setTimeout(() => {
          if (isRunning) {
            const beatWithinBar = (beatIndex % beatsPerBar) + 1;
            beatPositionReadout.textContent = beatWithinBar;
          }
        }, displayDelay);
      }

      function advanceToNextBeat() {
        const baseTempo = Number(tempoSlider.value);
        const variance = Number(varianceSlider.value);
        const erraticness = Number(erraticSlider.value);
        const profile = erraticProfiles[erraticness];

        // Update BPM variations for each beat
        maybeUpdateTargetBpm(baseTempo, variance, profile);
        adjustCurrentBpm(profile);
        updateStatusDisplays();

        // Calculate when the next beat should occur using the current (possibly drunk) BPM
        const beatInterval = 60.0 / currentBpm;
        nextBeatTime += beatInterval;

        beatIndex += 1;
      }

      function maybeUpdateTargetBpm(baseTempo, variance, profile) {
        if (variance === 0) {
          targetBpm = baseTempo;
          return;
        }

        if (Math.random() < profile.changeChance) {
          const range = variance * profile.rangeScale;
          const rawOffset = (Math.random() * 2 - 1) * range;
          const rawTarget = baseTempo + rawOffset;
          targetBpm = clamp(
            rawTarget,
            baseTempo - variance,
            baseTempo + variance
          );
        } else {
          // Slowly draw the target back toward the base tempo.
          targetBpm += (baseTempo - targetBpm) * 0.08;
        }
      }

      function adjustCurrentBpm(profile) {
        currentBpm += (targetBpm - currentBpm) * profile.smoothing;
        currentBpm = clamp(currentBpm, 20, 400);
      }

      function playClick(isDownbeat, time) {
        if (!audioContext) return;
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        const volume = 0.6;

        osc.type = "square";
        osc.frequency.setValueAtTime(isDownbeat ? 1100 : 750, time);

        // Use a deterministic envelope so perceived loudness stays consistent.
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(volume, time + 0.005);
        gain.gain.setValueAtTime(volume, time + 0.015);
        gain.gain.linearRampToValueAtTime(0, time + 0.09);

        osc.connect(gain);
        gain.connect(audioContext.destination);

        osc.start(time);
        osc.stop(time + 0.12);
      }

      function updateStatusDisplays(
        beatsPerBar = Number(beatsPerBarInput.value)
      ) {
        currentBpmReadout.textContent = Math.round(currentBpm);
        targetBpmReadout.textContent = targetBpm.toFixed(1);
        // Beat position is updated in scheduleNote() for better timing sync
      }

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      // Initialize displays with defaults.
      beatsPerBarDisplay.textContent = beatsPerBarInput.value;
      tempoDisplay.textContent = tempoSlider.value;
      varianceDisplay.textContent = varianceSlider.value;
      erraticDisplay.textContent = erraticLabels[erraticSlider.value];
      currentBpmReadout.textContent = tempoSlider.value;
      targetBpmReadout.textContent = tempoSlider.value;
      beatPositionReadout.textContent = "—";

      // Export functionality
      const exportBtn = document.getElementById("exportBtn");
      const exportDuration = document.getElementById("exportDuration");
      const exportStatus = document.getElementById("exportStatus");

      exportBtn.addEventListener("click", async () => {
        await exportToWav();
      });

      async function exportToWav() {
        // Parse duration
        const durationStr = exportDuration.value;
        const match = durationStr.match(/^(\d{1,2}):(\d{2})$/);
        if (!match) {
          exportStatus.textContent = "Invalid duration format. Use mm:ss";
          setTimeout(() => {
            exportStatus.textContent = "";
          }, 3000);
          return;
        }

        const minutes = parseInt(match[1]);
        const seconds = parseInt(match[2]);
        const totalSeconds = minutes * 60 + seconds;

        if (totalSeconds <= 0 || totalSeconds > 600) {
          exportStatus.textContent = "Duration must be between 0:01 and 10:00";
          setTimeout(() => {
            exportStatus.textContent = "";
          }, 3000);
          return;
        }

        exportStatus.textContent = "Generating...";
        exportBtn.disabled = true;

        try {
          // Create offline context
          const sampleRate = 44100;
          const offlineContext = new OfflineAudioContext(
            2,
            sampleRate * totalSeconds,
            sampleRate
          );

          // Pre-calculate all beats
          const beats = calculateAllBeats(totalSeconds);

          // Schedule all beats in the offline context
          beats.forEach((beat) => {
            renderClick(offlineContext, beat.isDownbeat, beat.time);
          });

          // Render the audio
          const buffer = await offlineContext.startRendering();

          // Convert to WAV and download
          const wav = audioBufferToWav(buffer);
          const blob = new Blob([wav], { type: "audio/wav" });
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = `drunk_metronome_${
            tempoSlider.value
          }bpm_${durationStr.replace(":", "m")}s.wav`;
          a.click();

          URL.revokeObjectURL(url);
          exportStatus.textContent = "Export complete!";
          setTimeout(() => {
            exportStatus.textContent = "";
          }, 3000);
        } catch (error) {
          console.error("Export failed:", error);
          exportStatus.textContent = "Export failed";
          setTimeout(() => {
            exportStatus.textContent = "";
          }, 3000);
        } finally {
          exportBtn.disabled = false;
        }
      }

      function calculateAllBeats(durationSeconds) {
        const beats = [];
        const beatsPerBar = Number(beatsPerBarInput.value);
        const baseTempo = Number(tempoSlider.value);
        const variance = Number(varianceSlider.value);
        const erraticness = Number(erraticSlider.value);
        const profile = erraticProfiles[erraticness];

        let currentTime = 0;
        let beatIdx = 0;
        let bpm = baseTempo;
        let target = baseTempo;

        while (currentTime < durationSeconds) {
          const isDownbeat = beatIdx % beatsPerBar === 0;
          beats.push({
            time: currentTime,
            isDownbeat: isDownbeat,
          });

          // Calculate next BPM (same logic as the live metronome)
          if (variance === 0) {
            target = baseTempo;
          } else {
            if (Math.random() < profile.changeChance) {
              const range = variance * profile.rangeScale;
              const rawOffset = (Math.random() * 2 - 1) * range;
              const rawTarget = baseTempo + rawOffset;
              target = clamp(
                rawTarget,
                baseTempo - variance,
                baseTempo + variance
              );
            } else {
              target += (baseTempo - target) * 0.08;
            }
          }

          bpm += (target - bpm) * profile.smoothing;
          bpm = clamp(bpm, 20, 400);

          const beatInterval = 60.0 / bpm;
          currentTime += beatInterval;
          beatIdx += 1;
        }

        return beats;
      }

      function renderClick(context, isDownbeat, time) {
        const osc = context.createOscillator();
        const gain = context.createGain();
        const volume = 0.6;

        osc.type = "square";
        osc.frequency.setValueAtTime(isDownbeat ? 1100 : 750, time);

        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(volume, time + 0.005);
        gain.gain.setValueAtTime(volume, time + 0.015);
        gain.gain.linearRampToValueAtTime(0, time + 0.09);

        osc.connect(gain);
        gain.connect(context.destination);

        osc.start(time);
        osc.stop(time + 0.12);
      }

      function audioBufferToWav(buffer) {
        const length = buffer.length * buffer.numberOfChannels * 2 + 44;
        const arrayBuffer = new ArrayBuffer(length);
        const view = new DataView(arrayBuffer);
        const channels = [];
        let offset = 0;
        let pos = 0;

        // Write WAV header
        const setUint16 = (data) => {
          view.setUint16(pos, data, true);
          pos += 2;
        };
        const setUint32 = (data) => {
          view.setUint32(pos, data, true);
          pos += 4;
        };

        // RIFF identifier
        setUint32(0x46464952); // "RIFF"
        setUint32(length - 8); // file length minus RIFF header
        setUint32(0x45564157); // "WAVE"

        // fmt sub-chunk
        setUint32(0x20746d66); // "fmt "
        setUint32(16); // size
        setUint16(1); // PCM
        setUint16(buffer.numberOfChannels);
        setUint32(buffer.sampleRate);
        setUint32(buffer.sampleRate * 2 * buffer.numberOfChannels); // avg bytes/sec
        setUint16(buffer.numberOfChannels * 2); // block align
        setUint16(16); // bits per sample

        // data sub-chunk
        setUint32(0x61746164); // "data"
        setUint32(length - pos - 4);

        // write interleaved data
        const numberOfChannels = buffer.numberOfChannels;
        for (let i = 0; i < numberOfChannels; i++) {
          channels.push(buffer.getChannelData(i));
        }

        while (pos < length) {
          for (let i = 0; i < numberOfChannels; i++) {
            // interleave channels
            let sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp
            sample = sample < 0 ? sample * 0x8000 : sample * 0x7fff; // scale to 16-bit
            view.setInt16(pos, sample, true);
            pos += 2;
          }
          offset++;
        }

        return arrayBuffer;
      }
    </script>
  </body>
</html>
